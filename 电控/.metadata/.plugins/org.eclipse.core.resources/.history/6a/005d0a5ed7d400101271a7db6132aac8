#include "oled.h"
#include <string.h>
#include "main.h"

// 屏幕/字符参数（8x16点阵）
#define SCREEN_WIDTH  128   // OLED宽度
#define SCREEN_HEIGHT 64    // OLED高度
#define CHAR_WIDTH    8     // 字符宽
#define CHAR_HEIGHT   16    // 字符高
#define FAZE_UP_LEN   7     // "FaZe up"字符数（F/a/Z/e/空格/u/p）
#define HYPER_LEN     5     // "hyper"字符数
#define ROLL_STEP     1     // 滚动步长（1像素）
#define ROLL_SPEED    20    // 滚动速度（ms/步）

// 状态枚举
typedef enum {
    SHOW_HYPER,
    SCROLL_FAZE_UP
} DisplayState;

// 全局变量
static I2C_HandleTypeDef *oled_hi2c;
static DisplayState current_state = SHOW_HYPER;
static uint32_t hyper_show_time = 0;
static const uint32_t HYPER_DURATION = 2000; // hyper显示时长(ms)
static int16_t scroll_y = -CHAR_HEIGHT;      // 竖直滚动Y坐标（从屏幕顶部外开始）

// ====================== 点阵数据（8x16，新宋体12号） ======================
// hyper字符点阵
const uint8_t HYPER_8x16[HYPER_LEN][16] = {
    // h
    {0x00,0x80,0x00,0x04,0x84,0xFC,0x04,0x04,0x00,0x01,0x01,0x01,0x00,0x01,0x01,0x01},
    // y
    {0x00,0xE8,0x24,0x24,0x24,0x24,0xF8,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00},
    // p
    {0x00,0x70,0x88,0x04,0x04,0x89,0xFF,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x01,0x01},
    // e
    {0x00,0x80,0x60,0x18,0x1E,0x61,0x81,0x00,0x01,0x01,0x01,0x00,0x00,0x01,0x01,0x01},
    // r
    {0x04,0xFC,0x04,0x00,0x00,0x84,0xFC,0x04,0x00,0x00,0x01,0x01,0x01,0x00,0x0F,0x08}
};

// FaZe up字符点阵（F/a/Z/e/空格/u/p）
const uint8_t FAZE_UP_8x16[FAZE_UP_LEN][16] = {
    // F
    {0x00,0x70,0x88,0x04,0x04,0x89,0xFF,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x01,0x01},
    // a
    {0x04,0xFC,0x08,0x04,0x04,0x04,0xF8,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01},
    // Z（修正为有效点阵）
    {0xFF,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0xFF},
    // e
    {0x00,0xE8,0x24,0x24,0x24,0x24,0xF8,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00},
    // 空格
    {0x00,0x18,0x04,0x04,0x84,0x64,0x1C,0x04,0x00,0x10,0x1C,0x13,0x10,0x10,0x10,0x08},
    // u
    {0x00,0x04,0xFC,0x48,0x24,0x24,0x98,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00},
    // p
    {0x00,0x00,0x00,0xC0,0x00,0x04,0xFC,0x04,0x00,0x08,0x10,0x17,0x11,0x11,0x1F,0x10}
};

// 连续滚动的FaZe up（拼接两组，修复初始化错误）
// 错误原因：原代码使用逗号分隔数组名，正确应逐个元素初始化
const uint8_t FAZE_UP_CONTINUOUS[FAZE_UP_LEN*2][16] = {
    // 第一组FaZe up
    {0x00,0x70,0x88,0x04,0x04,0x89,0xFF,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x01,0x01}, // F
    {0x04,0xFC,0x08,0x04,0x04,0x04,0xF8,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01}, // a
    {0xFF,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0xFF}, // Z
    {0x00,0xE8,0x24,0x24,0x24,0x24,0xF8,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00}, // e
    {0x00,0x18,0x04,0x04,0x84,0x64,0x1C,0x04,0x00,0x10,0x1C,0x13,0x10,0x10,0x10,0x08}, // 空格
    {0x00,0x04,0xFC,0x48,0x24,0x24,0x98,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00}, // u
    {0x00,0x00,0x00,0xC0,0x00,0x04,0xFC,0x04,0x00,0x08,0x10,0x17,0x11,0x11,0x1F,0x10}, // p

    // 第二组FaZe up（实现连续滚动）
    {0x00,0x70,0x88,0x04,0x04,0x89,0xFF,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x01,0x01}, // F
    {0x04,0xFC,0x08,0x04,0x04,0x04,0xF8,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x01}, // a
    {0xFF,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0xFF}, // Z
    {0x00,0xE8,0x24,0x24,0x24,0x24,0xF8,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00}, // e
    {0x00,0x18,0x04,0x04,0x84,0x64,0x1C,0x04,0x00,0x10,0x1C,0x13,0x10,0x10,0x10,0x08}, // 空格
    {0x00,0x04,0xFC,0x48,0x24,0x24,0x98,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x00,0x00}, // u
    {0x00,0x00,0x00,0xC0,0x00,0x04,0xFC,0x04,0x00,0x08,0x10,0x17,0x11,0x11,0x1F,0x10}  // p
};

// ====================== 内部函数 ======================
static void OLED_WriteCommand(uint8_t cmd) {
  HAL_I2C_Mem_Write(oled_hi2c, OLED_ADDR, 0x00, I2C_MEMADD_SIZE_8BIT, &cmd, 1, 1000);
}

static void OLED_WriteData(uint8_t data) {
  HAL_I2C_Mem_Write(oled_hi2c, OLED_ADDR, 0x40, I2C_MEMADD_SIZE_8BIT, &data, 1, 1000);
}

// 计算水平居中X坐标
static uint8_t GetCenterX(uint8_t char_count) {
    return (SCREEN_WIDTH - char_count * CHAR_WIDTH) / 2;
}

// ====================== 显示函数 ======================
void OLED_Init(I2C_HandleTypeDef *hi2c) {
  oled_hi2c = hi2c;
  HAL_Delay(300);

  // OLED初始化指令
  OLED_WriteCommand(0xAE); OLED_WriteCommand(0x20); OLED_WriteCommand(0x02);
  OLED_WriteCommand(0x00); OLED_WriteCommand(0x10); OLED_WriteCommand(0x40);
  OLED_WriteCommand(0xA0); OLED_WriteCommand(0xC0); OLED_WriteCommand(0xA6);
  OLED_WriteCommand(0xA8); OLED_WriteCommand(0x3F); OLED_WriteCommand(0xD3);
  OLED_WriteCommand(0x00); OLED_WriteCommand(0xD5); OLED_WriteCommand(0x80);
  OLED_WriteCommand(0xD9); OLED_WriteCommand(0xF1); OLED_WriteCommand(0xDA);
  OLED_WriteCommand(0x12); OLED_WriteCommand(0xDB); OLED_WriteCommand(0x40);
  OLED_WriteCommand(0x8D); OLED_WriteCommand(0x14); OLED_WriteCommand(0xAF);

  OLED_Clear();
  hyper_show_time = HAL_GetTick();
}

void OLED_Clear(void) {
  uint8_t page, col;
  for (page = 0; page < 8; page++) {
    OLED_WriteCommand(0xB0 + page);
    OLED_WriteCommand(0x00);
    OLED_WriteCommand(0x10);
    for (col = 0; col < 128; col++) {
      OLED_WriteData(0x00);
    }
  }
}

// 显示单个8x16字符
void OLED_ShowChar(uint8_t x, uint8_t y, const uint8_t *char_data) {
  uint8_t i;
  if (x >= 128 || y >= 7) return;

  // 上半部分（0-7行）
  OLED_WriteCommand(0xB0 + y);
  OLED_WriteCommand(0x00 + (x & 0x0F));
  OLED_WriteCommand(0x10 + (x >> 4));
  for (i = 0; i < 8; i++) OLED_WriteData(char_data[i]);

  // 下半部分（8-15行）
  OLED_WriteCommand(0xB0 + y + 1);
  OLED_WriteCommand(0x00 + (x & 0x0F));
  OLED_WriteCommand(0x10 + (x >> 4));
  for (i = 8; i < 16; i++) OLED_WriteData(char_data[i]);
}

// 显示居中的hyper
static void OLED_ShowHyper(void) {
    uint8_t x = GetCenterX(HYPER_LEN);
    uint8_t y = 2; // 垂直居中

    OLED_ShowChar(x + 0*8, y, HYPER_8x16[0]); // h
    OLED_ShowChar(x + 1*8, y, HYPER_8x16[1]); // y
    OLED_ShowChar(x + 2*8, y, HYPER_8x16[2]); // p
    OLED_ShowChar(x + 3*8, y, HYPER_8x16[3]); // e
    OLED_ShowChar(x + 4*8, y, HYPER_8x16[4]); // r
}

// 竖直滚动显示连续的FaZe up（从上到下）
static void OLED_DrawVerticalFaZeUp(int16_t start_y) {
    uint8_t base_x = GetCenterX(1); // 水平居中单个字符
    int16_t draw_y = start_y;
    uint8_t char_idx = 0;

    // 绘制连续字符，直到超出屏幕底部
    while (draw_y < SCREEN_HEIGHT + CHAR_HEIGHT && char_idx < FAZE_UP_LEN*2) {
        if (draw_y + CHAR_HEIGHT > 0) { // 字符顶部未超出屏幕
            uint8_t page = draw_y / 8;   // 转换为OLED页地址
            OLED_ShowChar(base_x, page, FAZE_UP_CONTINUOUS[char_idx]);
        }
        draw_y += CHAR_HEIGHT; // 下一个字符下移16像素
        char_idx++;
    }
}

// 主显示逻辑
void OLED_ShowMainLogic(void) {
    if (current_state == SHOW_HYPER) {
        OLED_Clear();
        OLED_ShowHyper();

        if (HAL_GetTick() - hyper_show_time >= HYPER_DURATION) {
            current_state = SCROLL_FAZE_UP;
            scroll_y = -CHAR_HEIGHT; // 初始位置：屏幕顶部外
        }
        HAL_Delay(100);
    } else {
        OLED_Clear();
        OLED_DrawVerticalFaZeUp(scroll_y);

        // 竖直滚动（下移）
        scroll_y += ROLL_STEP;

        // 重置滚动（当第一组完全滚出底部，回到顶部）
        if (scroll_y > SCREEN_HEIGHT + FAZE_UP_LEN*CHAR_HEIGHT) {
            scroll_y = -CHAR_HEIGHT;
        }

        HAL_Delay(ROLL_SPEED);
    }
}
