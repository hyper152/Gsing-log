#include "oled.h"
#include <string.h>

// 全局I2C句柄
static I2C_HandleTypeDef *oled_hi2c;

// 内部函数声明
static void OLED_WriteCommand(uint8_t cmd);
static void OLED_WriteData(uint8_t data);

// 8x16点阵库（仅保留hyper对应的字符，匹配取模工具输出）
const uint8_t ASCII_8x16[5][16] = {
    // h (对应索引0)
    [0] = {0x10,0xF0,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20},
    // y (对应索引1)
    [1] = {0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x81,0x86,0x78,0x18,0x06,0x01,0x00},
    // p (对应索引2)
    [2] = {0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0x91,0x20,0x20,0x11,0x0E,0x00},
    // e (对应索引3)
    [3] = {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x24,0x24,0x24,0x24,0x17,0x00},
    // r (对应索引4)
    [4] = {0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00}
};

// 字符映射：h->0, y->1, p->2, e->3, r->4
uint8_t get_index(uint8_t ch) {
  switch(ch) {
    case 'h': return 0;
    case 'y': return 1;
    case 'p': return 2;
    case 'e': return 3;
    case 'r': return 4;
    default: return 0; // 未知字符显示h
  }
}

// 发送命令（增加I2C超时）
static void OLED_WriteCommand(uint8_t cmd) {
  HAL_I2C_Mem_Write(oled_hi2c, OLED_ADDR, 0x00, I2C_MEMADD_SIZE_8BIT, &cmd, 1, 1000);
}

// 发送数据（增加I2C超时）
static void OLED_WriteData(uint8_t data) {
  HAL_I2C_Mem_Write(oled_hi2c, OLED_ADDR, 0x40, I2C_MEMADD_SIZE_8BIT, &data, 1, 1000);
}

// 初始化OLED（适配取模格式）
void OLED_Init(I2C_HandleTypeDef *hi2c) {
  oled_hi2c = hi2c;
  HAL_Delay(200);

  OLED_WriteCommand(0xAE);  // 关闭显示
  OLED_WriteCommand(0x20);  // 设置内存寻址模式
  OLED_WriteCommand(0x02);  // 页寻址模式
  OLED_WriteCommand(0x00);  // 低列地址
  OLED_WriteCommand(0x10);  // 高列地址
  OLED_WriteCommand(0x40);  // 起始行地址
  OLED_WriteCommand(0xB0);  // 页地址
  OLED_WriteCommand(0xA0);  // 段重映射（匹配取模方向）
  OLED_WriteCommand(0xA6);  // 正常显示
  OLED_WriteCommand(0xA8);  // 多路复用率
  OLED_WriteCommand(0x3F);
  OLED_WriteCommand(0xC0);  // COM扫描方向（匹配取模方向）
  OLED_WriteCommand(0xD3);  // 显示偏移
  OLED_WriteCommand(0x00);
  OLED_WriteCommand(0xD5);  // 时钟分频
  OLED_WriteCommand(0x80);
  OLED_WriteCommand(0xD9);  // 预充电周期
  OLED_WriteCommand(0xF1);
  OLED_WriteCommand(0xDA);  // COM引脚配置
  OLED_WriteCommand(0x12);
  OLED_WriteCommand(0xDB);  // VCOMH电平
  OLED_WriteCommand(0x40);
  OLED_WriteCommand(0x8D);  // 开启电荷泵
  OLED_WriteCommand(0x14);
  OLED_WriteCommand(0xAF);  // 开启显示
  OLED_Clear();
}

// 清屏
void OLED_Clear(void) {
  uint8_t i, j;
  for (i = 0; i < 8; i++) {
    OLED_WriteCommand(0xB0 + i);
    OLED_WriteCommand(0x00);
    OLED_WriteCommand(0x10);
    for (j = 0; j < 128; j++) {
      OLED_WriteData(0x00);
    }
  }
}

// 显示单个字符（适配新点阵格式）
void OLED_ShowChar(uint8_t x, uint8_t y, uint8_t ch) {
  uint8_t i;
  if (x >= 128 || y >= 7) return;
  uint8_t index = get_index(ch);
  if (index >= 5) return;

  // 设置坐标
  OLED_WriteCommand(0xB0 + y);
  OLED_WriteCommand(0x00 + (x & 0x0F));
  OLED_WriteCommand(0x10 + ((x >> 4) & 0x0F));

  // 写入点阵数据（直接使用工具生成的16字节）
  for (i = 0; i < 16; i++) {
    // 每8个字节切换一页（适配8x16显示）
    if (i == 8) {
      OLED_WriteCommand(0xB0 + y + 1);
      OLED_WriteCommand(0x00 + (x & 0x0F));
      OLED_WriteCommand(0x10 + ((x >> 4) & 0x0F));
    }
    OLED_WriteData(ASCII_8x16[index][i]);
  }
}

// 显示字符串
void OLED_ShowString(uint8_t x, uint8_t y, char *str) {
  uint8_t i = 0;
  while (str[i] != '\0') {
    OLED_ShowChar(x + i * 8, y, str[i]);
    i++;
    if (x + i * 8 >= 128) break;
  }
}
